<!DOCTYPE html>
<html>
<head><head>
<meta charset="UTF-8" >
<title>にじませるshader - js do it</title>
<meta name="Description" content="" >
<meta name="Keywords"  content="" >

<link rel="stylesheet" type="text/css" media="screen,print" href="style.css" >
</head>
<meta name="twitter:card" content="summary" >
<meta property="og:type" content="website" >
<meta property="og:url" content="https://takumifukasawa.github.io/jsdoitArchives/codes/a193c039-3658-5680-887c-84049b0bcfcf/" >
<meta property="og:title" content="にじませるshader - js do it" >
<meta property="og:description" content="&nbsp;" >
<meta property="og:image" content="https:/takumifukasawa.github.io/jsdoitArchives/codes/a193c039-3658-5680-887c-84049b0bcfcf/ogp.png" >
<meta property="og:image:width" content="1200" >
<meta property="og:image:height" content="630" >
</head>
<body>



<script id="fragment-shader">
    /*
    precision mediump float;
    varying vec2 vTextureCoord;
    uniform sampler2D uSampler;
    uniform sampler2D paper_map;
    
    void main(void) {
        vec4 texColor = texture2D(uSampler, vTextureCoord);   
        vec4 paperColor = texture2D(paper_map, vTextureCoord);
        vec4 color = texColor + paperColor;
        gl_FragColor = color;
    }
    */
    
    precision mediump float;
    
    uniform sampler2D uSampler;
    uniform sampler2D render_texture;
    uniform sampler2D paper_map;
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform vec2 u_mouse;
    uniform float range;

    varying vec2 vTextureCoord;    
    
    #define PI 3.141592653
    #define TWO_PI 6.283185307

    float getBri(vec4 col) {
        return 0.298912 * col.r + 0.586611 * col.g + 0.114478 * col.b;
    }

    vec3 rgb2hsv(vec3 c) {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    
        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    vec3 hsv2rgb(vec3 c) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }

    float mod289(float x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec2 mod289(vec2 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec3 mod289(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    vec4 mod289(vec4 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
    }

    float permute(float x) {
        return mod289(((x*34.0)+1.0)*x);
    }

    vec3 permute(vec3 x) {
        return mod289(((x*34.0)+1.0)*x);
    }

    vec4 permute(vec4 x) {
        return mod289(((x*34.0)+1.0)*x);
    }

    float taylorInvSqrt(float r) {
        return 1.79284291400159 - 0.85373472095314 * r;
    }

    vec4 taylorInvSqrt(vec4 r) {
        return 1.79284291400159 - 0.85373472095314 * r;
    }

    vec4 grad4(float j, vec4 ip) {
        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
        vec4 p,s;
    
        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
        s = vec4(lessThan(p, vec4(0.0)));
        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
    
        return p;
    }

    float simplexNoise(vec2 v) {
        const vec4 C = vec4(
             0.211324865405187, // (3.0-sqrt(3.0))/6.0
             0.366025403784439, // 0.5*(sqrt(3.0)-1.0)
             -0.577350269189626, // -1.0 + 2.0 * C.x
             0.024390243902439 // 1.0 / 41.0
        );
        // First corner
        vec2 i = floor(v + dot(v, C.yy) );
        vec2 x0 = v - i + dot(i, C.xx);
    
        // Other corners
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
    
        // Permutations
        i = mod289(i); // Avoid truncation effects in permutation
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
            + i.x + vec3(0.0, i1.x, 1.0 ));
    
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;
    
        // Gradients: 41 points uniformly over a line, mapped onto a diamond.
        // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)
    
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
    
        // Normalise gradients implicitly by scaling m
        // Approximation of: m *= inversesqrt( a0*a0 + h*h );
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    
        // Compute final noise value at P
        vec3 g;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
    }

    float simplexNoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
        // First corner
        vec3 i = floor(v + dot(v, C.yyy) );
        vec3 x0 = v - i + dot(i, C.xxx) ;
    
        // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );
    
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y
    
        // Permutations
        i = mod289(i);
        vec4 p = permute( permute( permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 )
        );
    
        // Gradients: 7x7 points over a square, mapped onto an octahedron.
        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
        float n_ = 0.142857142857; // 1.0/7.0
        vec3 ns = n_ * D.wyz - D.xzx;
    
        vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)
    
        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)
    
        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);
    
        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );
    
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));
    
        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
    
        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);
    
        //Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
    
        // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
            dot(p2,x2), dot(p3,x3) ) );
    }

    float _map(float val, float _min, float _max, float t_min, float t_max) {
        float rat = (val - _min) / (_max - _min);
        return (t_max - t_min) * rat + t_min;
    }

    float random (vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);
    }




    //↑ simplexNoiseアルゴリズム
    //-------------------------------------
    //↓ 実質的な処理


    void main() {
    
        //1:自ピクセルの周囲にあるピクセルの色を一定のルールで参照
        //2:参照ピクセルと背景イメージ（紙）の輝度値をもとに自ピクセルの色と混ぜ合わせる
        //3:1と2を毎フレームで繰り返す
    
        vec4 modifyColor = texture2D(uSampler, vTextureCoord);
        vec4 paperColor = texture2D(paper_map, vTextureCoord);
    
        float bri = getBri(modifyColor);
        float paperBri = getBri(paperColor)*.5;
        //float paperBri = getBri(paperColor);
        
        float radX = range;
        float radY = range;
        float movX;
        float movY;
        float theta;
        
        if (bri >= 0.1) {
            vec3 noiseSeed = vec3(vTextureCoord.x*0.2, vTextureCoord.y*0.2, u_time);
            float coordSeed = simplexNoise(noiseSeed);
            theta = _map(coordSeed, 0.0, 1.0, 0.0, TWO_PI);
            movX = cos(theta)*radX;
            movY = sin(theta)*radY;

            vec2 lookCoord = vTextureCoord.xy + vec2(movX, movY);
            vec4 mixColor = texture2D(uSampler, lookCoord);
            float addBri = getBri(mixColor);        

            if (addBri != 0.0 && paperBri != 0.0) {
                if (paperBri <= 0.05) {
                    if (paperBri == 0.0) { paperBri = 0.02; }
                    float d = paperBri * 1.5;
                    modifyColor = vec4(d,d,d,1.0);
                } else if (paperBri >= 0.49) {
                    float distance = .5 + paperBri;
                    vec3 d = mix(vec3(1.0), mixColor.rgb, distance);
                    modifyColor = vec4(d,1.0);             
                } else {                
                    vec3 originHsv = rgb2hsv(modifyColor.rgb);
                    vec3 mixHsv = rgb2hsv(mixColor.rgb);
                    //float briDiff = abs(mixHsv.z - originHsv.z);
                    
                    float distance = .5 + paperBri - (originHsv.y * .5);
                    modifyColor = mix(modifyColor, mixColor, distance);
                }
            }            
        }

        
        gl_FragColor = modifyColor;
        //gl_FragColor = vec4(vTextureCoord.x, vTextureCoord.y, 1., 1.);
        
        //gl_FragColor = vec4(1., 0., 0., 1.);        
        //gl_FragColor = paperColor;
        //gl_FragColor = vec4(bri, 0., 0., 1.);
        //gl_FragColor = vec4(0., 0., 0., paperBri);
        //gl_FragColor = texture2D(uSampler, vTextureCoord);
        //gl_FragColor = vec4(u_mouse.x / u_resolution.x, 1., 1., 1.);
        //gl_FragColor = vec4(sin(u_time), u_mouse.x / u_resolution.x, u_mouse.y / u_resolution.y, 1.);
    }

</script>

<div class="wrapper">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>

<script type="text/javascript" src="index.js"></script>
</body>
</html>
